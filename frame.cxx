// frame.cxx
// Copyright (c) 2025, 张子辰

// This file is part of HDR Image Frame.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:

// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.

// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Disclosure of Generative AI Usage:
// This file was initially generated by Google Gemini 3 Pro, but thoroughly reviewed,
// debugged, and revised by the author. Please refer to commit 5d73a79 for the
// AI-generated text.

#include <iostream>
#include <vector>
#include <string>
#include <string_view>
#include <fstream>
#include <cmath>
#include <algorithm>
#include <format>
#include <filesystem>

#include <opencv2/opencv.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/imgcodecs.hpp>

#include <exiv2/exiv2.hpp>

#include <ft2build.h>
#include <freetype/freetype.h>

#include <ultrahdr_api.h>

using std::cout, std::cerr, std::endl, std::ifstream, std::ofstream, std::ios;
using std::string, std::vector, std::format;
using cv::Mat, cv::Point, cv::Scalar;
using namespace std::string_literals;
using namespace std::string_view_literals;
namespace fs = std::filesystem;

constexpr int JPEG_QUALITY = 95;
constexpr auto BOLD_FONTS = {"/usr/share/fonts/truetype/noto/NotoSans-Bold.ttf"sv, "/usr/share/fonts/truetype/noto/NotoSansSymbols2-Regular.ttf"sv};
constexpr auto REGULAR_FONTS = {"/usr/share/fonts/truetype/noto/NotoSans-Regular.ttf"sv, "/usr/share/fonts/truetype/noto/NotoSansSymbols2-Regular.ttf"sv};

// =========================================== //
// Executable directory (including /)
fs::path get_executable_directory();

// =========================================== //
// UTF-8 iterator
class unicode_iterator {
public:
    using iterator_category = std::forward_iterator_tag;
    using value_type        = char32_t;
    using difference_type   = std::ptrdiff_t;
    using pointer           = const char32_t*;
    using reference         = const char32_t;

    char32_t operator*() const {
        if (m_it == m_end) return 0;

        auto c = static_cast<unsigned char>(*m_it);
        uint32_t codepoint = 0;

        if ((c & 0x80) == 0)
            return static_cast<char32_t>(c);
        else if ((c & 0xE0) == 0xC0)
            return decode_n(1, c & 0x1F);
        else if ((c & 0xF0) == 0xE0)
            return decode_n(2, c & 0x0F);
        else if ((c & 0xF8) == 0xF0)
            return decode_n(3, c & 0x07);
        else
            return 0xFFFD; // Replacement Character
    }

    unicode_iterator& operator++() {
        if (m_it == m_end) return *this;

        auto c = static_cast<unsigned char>(*m_it);
        size_t len;

        if ((c & 0x80) == 0) len = 1;
        else if ((c & 0xE0) == 0xC0) len = 2;
        else if ((c & 0xF0) == 0xE0) len = 3;
        else if ((c & 0xF8) == 0xF0) len = 4;
        else len = 1;

        for (size_t i = 0; i < len && m_it != m_end; ++i, ++m_it);
        return *this;
    }

    unicode_iterator operator++(int) {
        auto tmp = *this;
        ++(*this);
        return tmp;
    }

    bool operator==(const unicode_iterator& other) const {
        return m_it == other.m_it;
    }

    bool operator!=(const unicode_iterator& other) const {
        return !(*this == other);
    }

    friend unicode_iterator utf8_begin(const string &str);
    friend unicode_iterator utf8_end(const string &str);

protected:
    unicode_iterator(string::const_iterator it, string::const_iterator end)
        : m_it(it), m_end(end) {}

private:
    string::const_iterator m_it;
    string::const_iterator m_end;

    char32_t decode_n(int n, uint32_t cp) const {
        auto temp_it = m_it;

        for (int i = 0; i < n; ++i) {
            if (++temp_it == m_end) return 0xFFFD;

            unsigned char next_c = static_cast<unsigned char>(*temp_it);
            if ((next_c & 0xC0) != 0x80) return 0xFFFD;

            cp = (cp << 6) | (next_c & 0x3F);
        }
        return static_cast<char32_t>(cp);
    }
};

unicode_iterator utf8_begin(const string &str) {
    return unicode_iterator(str.begin(), str.end());
}

unicode_iterator utf8_end(const string &str) {
    return unicode_iterator(str.end(), str.end());
}

// =========================================== //
// Text renderer
class TextRenderer {
    FT_Library ft;
    vector<FT_Face> faces;

public:
    TextRenderer(std::initializer_list<std::string_view> fontPaths, int fontSize) {
        if (FT_Init_FreeType(&ft)) {
            cerr << "ERROR: Could not init FreeType Library" << endl;
            return;
        }
        for (auto fontPath: fontPaths) {
            FT_Face face;
            if (FT_New_Face(ft, fontPath.data(), 0, &face)) {
                cerr << "ERROR: Failed to load font: " << fontPath << endl;
                return;
            }
            FT_Set_Pixel_Sizes(face, 0, fontSize);
            faces.push_back(face);
        }
    }

    ~TextRenderer() {
        for (auto &face: faces)
            FT_Done_Face(face);
        FT_Done_FreeType(ft);
    }

    // Templated to handle CV_8U (SDR) and CV_32F (HDR)
    void putText(Mat& img, const string& text, Point pos, Scalar color) {
        auto pen_x = pos.x;
        auto pen_y = pos.y;

        for (auto it = utf8_begin(text); it != utf8_end(text); ++it) {
            // Try rendering the codepoint in all avaliable fonts
            for (auto &face : faces) {
                if (FT_Get_Char_Index(face, *it) == 0 || FT_Load_Char(face, *it, FT_LOAD_RENDER)) continue;
                FT_Bitmap& bitmap = face->glyph->bitmap;
                auto top = pen_y - face->glyph->bitmap_top;
                auto left = pen_x + face->glyph->bitmap_left;

                for (int r = 0; r < bitmap.rows; r++) {
                    for (int c = 0; c < bitmap.width; c++) {
                        auto y = top + r;
                        auto x = left + c;

                        if (y < 0 || y >= img.rows || x < 0 || x >= img.cols) continue;

                        double alpha = bitmap.buffer[r * bitmap.width + c] / 255.0;
                        if (alpha > 0) {
                            // Handle Multi-channel generic
                            auto channels = img.channels();
                            if (img.depth() == CV_8U) {
                                cv::Vec3b& pixel = img.at<cv::Vec3b>(y, x);
                                for (int i = 0; i < 3; i++)
                                    pixel[i] = (uchar)(pixel[i] * (1.0 - alpha) + color[i] * alpha);
                            } else if (img.depth() == CV_32F) {
                                cv::Vec3f& pixel = img.at<cv::Vec3f>(y, x);
                                for (int i = 0; i < 3; i++)
                                    pixel[i] = (float)(pixel[i] * (1.0 - alpha) + color[i] * alpha);
                            }
                        }
                    }
                }
                pen_x += (face->glyph->advance.x >> 6);
                break;
            }
        }
    }

    int getTextWidth(const string& text) {
        int width = 0;
        for (auto it = utf8_begin(text); it != utf8_end(text); ++it) {
            for (auto &face : faces) {
                if (FT_Get_Char_Index(face, *it) == 0 || FT_Load_Char(face, *it, FT_LOAD_RENDER)) continue;
                width += (face->glyph->advance.x >> 6);
                break;
            }
        }
        return width;
    }
};

// =========================================== //
// Meta data parser
struct Metadata {
    string make;
    string model;
    string lens;
    string iso;
    string f_number;
    string shutter;
    string focal;
    string date;
    string coordinate;
};

Metadata parseExif(const Exiv2::ExifData &exifData) {
    using Exiv2::ExifKey;
    Metadata meta;
    try {
        if (!exifData.empty()) {
            if (auto key = exifData.findKey(ExifKey("Exif.Image.Make")); key != exifData.end())
                meta.make = key->toString();
            if (auto key = exifData.findKey(ExifKey("Exif.Image.Model")); key != exifData.end()) {
                meta.model = key->toString();
                if (meta.make == "") {
                    // If Make is none, try inferring it from Model
                    meta.make = meta.model.substr(0,meta.model.find(" "));
                }
                auto m = meta.model; std::transform(m.begin(), m.end(), m.begin(), ::tolower);
                if (m.ends_with(" digital camera"))
                    meta.model.resize(meta.model.length()-" digital camera"s.length());
            }
            if (auto key = exifData.findKey(ExifKey("Exif.Photo.FNumber")); key != exifData.end()) {
                auto val = key->toFloat();
                auto s = format("{:.3f}", val);
                while (s.back() == '0') s.pop_back();
                if (s.back() == '.') s += '0';
                meta.f_number = "f/" + s;
            }
            if (auto key = exifData.findKey(ExifKey("Exif.Photo.ExposureTime")); key != exifData.end()) {
                auto r = key->toRational();
                if (r.first >= r.second) meta.shutter = format("{}s",r.first / r.second);
                else meta.shutter = format("1/{}s", int(round((double)r.second/r.first)));
            }
            if (auto key = exifData.findKey(ExifKey("Exif.Photo.ISOSpeedRatings")); key != exifData.end())
                meta.iso = "ISO" + key->toString();
            if (auto key = exifData.findKey(ExifKey("Exif.Photo.FocalLength")); key != exifData.end()) {
                float val = key->toFloat();
                auto s = format("{:.3f}", val);
                while (s.back() == '0') s.pop_back();
                if (s.back() == '.') s += '0';
                meta.focal = s + "mm";
            }
            if (auto key = exifData.findKey(ExifKey("Exif.Photo.LensModel")); key != exifData.end()) {
                meta.lens = key->toString();
                if (meta.model != "" && meta.lens.starts_with(meta.model+" ")) {
                    meta.lens = meta.lens.substr(meta.model.length()+1);
                }
            }
            else
                meta.lens = "builtin lens";
            if (auto key = exifData.findKey(ExifKey("Exif.Photo.DateTimeOriginal")); key != exifData.end()) {
                string d = key->toString();
                d[4] = '-'; d[7] = '-'; d[10]='T';
                meta.date = d;
                if (auto key = exifData.findKey(ExifKey("Exif.Photo.OffsetTimeOriginal")); key != exifData.end()) {
                    auto s = key->toString();
                    if (s == "+00:00") meta.date += "Z";
                    else meta.date += s;
                }
            }
            if (auto key = exifData.findKey(ExifKey("Exif.GPSInfo.GPSLatitude")); key != exifData.end()) {
                // assume GPS data is complete
                auto latitude = key->toFloat(0) + key->toFloat(1)/60.0f + key->toFloat(2)/3600.0f;
                auto key2 = exifData.findKey(ExifKey("Exif.GPSInfo.GPSLongitude"));
                auto longitude = key2->toFloat(0) + key2->toFloat(1)/60.0f + key2->toFloat(2)/3600.0f;
                auto latitude_ref = exifData.findKey(ExifKey("Exif.GPSInfo.GPSLatitudeRef"))->toString();
                auto longitude_ref = exifData.findKey(ExifKey("Exif.GPSInfo.GPSLongitudeRef"))->toString();
                meta.coordinate = format("{:.5f}{},{:.5f}{}", latitude, latitude_ref, longitude, longitude_ref);
                if (auto key = exifData.findKey(ExifKey("Exif.GPSInfo.GPSAltitude")); key != exifData.end()) {
                    int height = std::round(key->toFloat());
                    if (auto key = exifData.findKey(ExifKey("Exif.GPSInfo.GPSAltitudeRef")); key != exifData.end()) {
                        if (key->toLong() == 1) height = -height;
                    }
                    meta.coordinate += format(",{:+}m",height);
                }
            }
        }
    } catch (Exiv2::Error& e) {
        cerr << "Exif Parsing Error: " << e.what() << endl;
    }
    return meta;
}

Exiv2::ExifData getExif(const vector<char> &buf) {
    auto image = Exiv2::ImageFactory::open(reinterpret_cast<const Exiv2::byte*>(buf.data()), buf.size());
    image->readMetadata();
    return image->exifData();
}

bool checkUhdr(uhdr_error_info_t status, const string& msg) {
    if (status.error_code != UHDR_CODEC_OK) {
        cerr << "[UltraHDR] " << msg << " Failed: " << status.error_code;
        if (status.has_detail) cerr << " (" << status.detail << ")";
        cerr << endl;
        return false;
    }
    return true;
}

Mat wrapUhdrImage(uhdr_raw_image_t* img) {
    if (!img) return Mat();
    if (img->fmt == UHDR_IMG_FMT_32bppRGBA8888)
        return Mat(img->h, img->w, CV_8UC4, img->planes[UHDR_PLANE_PACKED]);
    if (img->fmt == UHDR_IMG_FMT_64bppRGBAHalfFloat)
        return Mat(img->h, img->w, CV_16FC4, img->planes[UHDR_PLANE_PACKED]);
    return Mat();
}

string defaultOuput(const string &input) {
    auto i = input.length();
    while(i && input[--i] != '.'); // find suffix

    if (i == 0) // no suffix
        return input + ".framed";
    else
        return input.substr(0, i) + ".framed" + input.substr(i);
}

int main(int argc, char** argv) {
    if (argc < 2) {
        cout << "Usage: " << argv[0] << " <input.jpg> [output.jpg]" << endl;
        return 1;
    }
    string inputPath = argv[1];
    string outputPath = (argc > 2) ? argv[2] : defaultOuput(inputPath);

    // 1. Read Input
    ifstream file(inputPath, ios::binary | ios::ate);
    if (!file.good()) { cerr << "File error." << endl; return -1; }
    size_t size = file.tellg();
    file.seekg(0, ios::beg);
    vector<char> buffer(size);
    file.read(buffer.data(), size);

    // 2. Decode (Dual Pass if UltraHDR)
    Mat sdrMat, hdrMat; // sdrMat is BGR (8u), hdrMat is BGR (32f Linear)
    auto hasHDR = false;

    cout << "Decoding SDR plane..." << endl;
    sdrMat = cv::imdecode(buffer, cv::IMREAD_COLOR);
    if (sdrMat.empty()) { cerr << "Decode failed." << endl; return -1; }

    auto exif = getExif(buffer);

    if (is_uhdr_image(buffer.data(), size)) {
        cout << "Decoding HDR plane..." << endl;

        uhdr_codec_private_t* dec = uhdr_create_decoder();
        uhdr_compressed_image_t input_img = { buffer.data(), size, size, UHDR_CG_UNSPECIFIED, UHDR_CT_UNSPECIFIED, UHDR_CR_UNSPECIFIED };
        uhdr_dec_set_image(dec, &input_img);
        uhdr_dec_set_out_img_format(dec, UHDR_IMG_FMT_64bppRGBAHalfFloat);
        uhdr_dec_set_out_color_transfer(dec, UHDR_CT_LINEAR); // Essential for raw linear data
        uhdr_dec_probe(dec);
        if (uhdr_decode(dec).error_code == UHDR_CODEC_OK) {
            auto raw16 = wrapUhdrImage(uhdr_get_decoded_image(dec)); // CV_16FC4

            // Convert 16F -> 32F first to avoid OpenCV cvtColor issues with 16-bit float
            Mat raw32;
            raw16.convertTo(raw32, CV_32F);

            // Now safe to convert Color space on 32F image
            cvtColor(raw32, hdrMat, cv::COLOR_RGBA2BGR);

            hasHDR = true;
        }
        uhdr_release_decoder(dec);
    }

    // 3. Resize & Pad
    int targetW = 2160;
    int targetH = targetW * 1.25;
    int margin = 80;
    int bottomPad = 300;

    auto layout = [&](const Mat& src, Mat& dst, Scalar padColor, int interp) {
        double scale = std::min((double)(targetW - margin*2) / src.cols, (double)(targetH - margin*2 - bottomPad) / src.rows);
        int dw = src.cols * scale;
        int dh = src.rows * scale;
        int x = (targetW - dw) / 2;
        int y = margin + (targetH - margin*2 - bottomPad - dh) / 2;

        dst.setTo(padColor);
        Mat resized;
        resize(src, resized, cv::Size(dw, dh), 0, 0, interp);
        resized.copyTo(dst(cv::Rect(x, y, dw, dh)));
    };

    Mat sdrCanvas(targetH, targetW, CV_8UC3);
    layout(sdrMat, sdrCanvas, Scalar(255, 255, 255), cv::INTER_LANCZOS4);

    Mat hdrCanvas;
    if (hasHDR) {
        hdrCanvas.create(targetH, targetW, CV_32FC3);
        // Pad with 1.0 (SDR White in Linear HDR)
        layout(hdrMat, hdrCanvas, Scalar(1.0f, 1.0f, 1.0f), cv::INTER_LANCZOS4);
    }

    // 4. Draw Metadata
    auto meta = parseExif(exif);
    TextRenderer fontMain(BOLD_FONTS, 52);
    TextRenderer fontSub(REGULAR_FONTS, 40);

    auto maintext = format("{} ⋅ {} ⋅ {} ⋅ {}", meta.f_number, meta.shutter, meta.focal, meta.iso);
    auto subtext = meta.date;
    if (meta.coordinate != "") {
        (subtext += " ⋅ ") += meta.coordinate;
    }
    int footerY = targetH - bottomPad + 60;

    // SDR Colors
    Scalar sdrText(0,0,0);
    Scalar sdrSub(100,100,100);

    // HDR Colors (Linear)
    // Black is 0. Gray #666 (0.4 sRGB) is approx 0.133 Linear
    Scalar hdrText(0,0,0);
    Scalar hdrSub(0.133, 0.133, 0.133);

    // Draw SDR
    fontMain.putText(sdrCanvas, maintext, Point(margin, footerY + 52), sdrText);
    fontSub.putText(sdrCanvas, subtext, Point(margin, footerY + 122), sdrSub);

    // Draw HDR
    if (hasHDR) {
        fontMain.putText(hdrCanvas, maintext, Point(margin, footerY + 52), hdrText);
        fontSub.putText(hdrCanvas, subtext, Point(margin, footerY + 122), hdrSub);
    }

    // Logos
    auto logoPath = get_executable_directory();
    bool hasMakeLogo = false;
    if (fs::is_directory(logoPath / "../share/hiframe/logo")) logoPath /= "../share/hiframe/logo";
    else if (is_directory(logoPath / "logo")) logoPath /= "logo";
    else cerr << "Unable to find logo images" << endl;

    auto m = meta.make; std::transform(m.begin(), m.end(), m.begin(), ::tolower);
    for (const auto &logo : fs::directory_iterator(logoPath)) {
        auto p = logo.path();
        if (p.filename() == "default.png") continue;
        auto stem = p.stem().string();
        if (m.find(stem) != string::npos) {
            logoPath = p;
            hasMakeLogo = true;
            break;
        }
    }
    if (!hasMakeLogo) {
        cerr << "Unknown manufacture: " << meta.make << "; fallback to default logo" << endl;
        logoPath /= "default.png";
    }

    Mat logo = cv::imread(logoPath, cv::IMREAD_UNCHANGED);
    if (!logo.empty()) {
        if (logo.channels() < 4) cvtColor(logo, logo, logo.channels()==1 ? cv::COLOR_GRAY2BGRA : cv::COLOR_BGR2BGRA);

        auto logosize = logo.size();
        double logoresize_ratio = std::min(120.0/logosize.height, 240.0/logosize.width);
        int hsize = std::round(logosize.width*logoresize_ratio);
        int vsize = std::round(logosize.height*logoresize_ratio);
        resize(logo, logo, cv::Size(hsize,vsize), 0, 0, cv::INTER_AREA);
        int lx = targetW - margin - hsize;
        int ly = footerY + (120-vsize)/2;

        // Blend SDR
        for(int r=0; r<logo.rows; r++) {
            for(int c=0; c<logo.cols; c++) {
                cv::Vec4b p = logo.at<cv::Vec4b>(r,c);
                float a = p[3]/255.f;
                if(a>0) {
                    cv::Vec3b& b = sdrCanvas.at<cv::Vec3b>(ly+r, lx+c);
                    for(int k=0;k<3;k++) b[k] = cv::saturate_cast<uchar>(b[k]*(1-a) + p[k]*a);
                }
            }
        }

        // Blend HDR (Linear)
        if (hasHDR) {
            for(int r=0; r<logo.rows; r++) {
                for(int c=0; c<logo.cols; c++) {
                    cv::Vec4b p = logo.at<cv::Vec4b>(r,c);
                    float a = p[3]/255.f;
                    if(a>0) {
                        cv::Vec3f& b = hdrCanvas.at<cv::Vec3f>(ly+r, lx+c);
                        for(int k=0;k<3;k++) {
                            // Convert logo sRGB to Linear: pow(x/255, 2.2)
                            float val = pow(p[k]/255.f, 2.2f);
                            b[k] = b[k]*(1-a) + val*a;
                        }
                    }
                }
            }
        }

        string cam = meta.model;
        int w = fontMain.getTextWidth(cam);
        fontMain.putText(sdrCanvas, cam, Point(lx - 40 - w, footerY + 52), sdrText);
        if (hasHDR) fontMain.putText(hdrCanvas, cam, Point(lx - 40 - w, footerY + 52), hdrText);

        if(!meta.lens.empty()) {
            int w2 = fontSub.getTextWidth(meta.lens);
            fontSub.putText(sdrCanvas, meta.lens, Point(lx - 40 - w2, footerY + 122), sdrSub);
            if(hasHDR) fontSub.putText(hdrCanvas, meta.lens, Point(lx - 40 - w2, footerY + 122), hdrSub);
        }
    }

    // 5. Encode (Raw SDR + Raw HDR)
    cout << "Encoding..." << endl;

    // update some EXIF data regarding the new image.
    if (!exif.empty()) {
        using namespace Exiv2;
        if (auto key = exif.findKey(ExifKey("Exif.Image.Orientation")); key != exif.end())
        exif.erase(key);
        if (auto key = exif.findKey(ExifKey("Exif.Image.ImageWidth")); key != exif.end())
            *key = targetW;
        if (auto key = exif.findKey(ExifKey("Exif.Image.ImageLength")); key != exif.end())
            *key = targetH;
    }

    if (hasHDR) {
        // Prepare Raw Images
        // SDR: Convert BGR to RGBA
        Mat sdrRaw; cvtColor(sdrCanvas, sdrRaw, cv::COLOR_BGR2RGBA);

        // HDR: Convert BGR Linear Float to RGBA Half Float (16F)
        Mat hdrLinear; cvtColor(hdrCanvas, hdrLinear, cv::COLOR_BGR2RGBA);
        Mat hdrHalf; hdrLinear.convertTo(hdrHalf, CV_16F);

        auto enc = uhdr_create_encoder();

        uhdr_raw_image_t sdr_img = { UHDR_IMG_FMT_32bppRGBA8888, UHDR_CG_BT_709, UHDR_CT_SRGB, UHDR_CR_FULL_RANGE,
                                     (unsigned)sdrRaw.cols, (unsigned)sdrRaw.rows };
        sdr_img.planes[UHDR_PLANE_PACKED] = sdrRaw.data;
        sdr_img.stride[UHDR_PLANE_PACKED] = sdrRaw.cols; // Stride in pixels

        uhdr_raw_image_t hdr_img = { UHDR_IMG_FMT_64bppRGBAHalfFloat, UHDR_CG_BT_709, UHDR_CT_LINEAR, UHDR_CR_FULL_RANGE,
                                     (unsigned)hdrHalf.cols, (unsigned)hdrHalf.rows };
        hdr_img.planes[UHDR_PLANE_PACKED] = hdrHalf.data;
        hdr_img.stride[UHDR_PLANE_PACKED] = hdrHalf.cols;

        checkUhdr(uhdr_enc_set_raw_image(enc, &sdr_img, UHDR_SDR_IMG), "Set SDR");
        checkUhdr(uhdr_enc_set_raw_image(enc, &hdr_img, UHDR_HDR_IMG), "Set HDR");
        checkUhdr(uhdr_enc_set_quality(enc, JPEG_QUALITY, UHDR_BASE_IMG), "Set Base Quality");
        checkUhdr(uhdr_enc_set_quality(enc, JPEG_QUALITY, UHDR_GAIN_MAP_IMG), "Set Gain Map Quality");

        vector<uint8_t> exif_raw;
        if (!exif.empty()) {
            vector<uint8_t> exif_raw0;
            Exiv2::ExifParser::encode(exif_raw0, Exiv2::littleEndian, exif);

            // The EXIF data encoded by Exiv 2 lacks header, so add it back.
            exif_raw.resize(exif_raw0.size()+6);
            memcpy(exif_raw.data(), "Exif\0", 6);
            memcpy(exif_raw.data()+6, exif_raw0.data(), exif_raw0.size());

            uhdr_mem_block_t eb = { exif_raw.data(), exif_raw.size(), exif_raw.size() };
            checkUhdr(uhdr_enc_set_exif_data(enc, &eb), "Set EXIF");
        }

        if (checkUhdr(uhdr_encode(enc), "Encode")) {
            auto out = uhdr_get_encoded_stream(enc);
            ofstream f(outputPath, ios::binary);
            f.write((char*)out->data, out->data_sz);
            cout << "Saved UltraHDR: " << outputPath << endl;
        }
        uhdr_release_encoder(enc);
    } else {
        // Standard JPEG
        vector<uchar> buf;
        vector<int> p = {cv::IMWRITE_JPEG_QUALITY, JPEG_QUALITY};
        imencode(".jpg", sdrCanvas, buf, p);
        ofstream f(outputPath, ios::binary);
        f.write((char*)buf.data(), buf.size());
        f.close();

        try {
            Exiv2::Image::AutoPtr dst = Exiv2::ImageFactory::open(outputPath); dst->readMetadata();
            dst->setExifData(exif);
            dst->writeMetadata();
        } catch(...) {}
        cout << "Saved SDR: " << outputPath << endl;
    }

    return 0;
}
